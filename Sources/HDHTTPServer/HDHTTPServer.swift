//
//  HDHTTPServer.swift
//  HDHTTPServer
//
//  Created by Yuki Takahashi on 2017/11/11.
//

import Dispatch

public struct HTTPRequest { }

public struct HTTPResponseWriter { }

public struct HTTPBodyProcessing { }

public typealias HTTPRequestHandler = (HTTPRequest, HTTPResponseWriter) -> HTTPBodyProcessing

public class HDHTTPServer<Manager: ClientSocketHandlerManager> {
    private let serverSocket: SSSocket

    private var clientSocketHandlerManager: Manager

    /// Timer that cleans up idle sockets on expire
    private let pruneSocketTimer: DispatchSourceTimer = DispatchSource.makeTimerSource(queue: DispatchQueue(label: "pruneSocketTimer"))

    public var port: Int {
        return Int(serverSocket.listeningPort)
    }

    public init(serverSocket: SSSocket, clientSocketHandlerManager: Manager) {
        self.serverSocket = serverSocket
        self.clientSocketHandlerManager = clientSocketHandlerManager
    }

    private var queueMax: Int = 4
    private var acceptMax: Int = 8
    private let _isShuttingDownLock = DispatchSemaphore(value: 1)
    private var _isShuttingDown: Bool = false

    var isShuttingDown: Bool {
        get {
            _isShuttingDownLock.wait()
            defer {
                _isShuttingDownLock.signal()
            }
            return _isShuttingDown
        }
        set {
            _isShuttingDownLock.wait()
            defer {
                _isShuttingDownLock.signal()
            }
            _isShuttingDown = newValue
        }
    }

    /// Starts the server listening on a given port
    ///
    /// - Parameters:
    ///   - port: TCP port. See listen(2)
    ///   - handler: Function that creates the HTTP Response from the HTTP Request
    /// - Throws: Error (usually a socket error) generated
    public func start(port: Int = 0,
                      queueCount: Int = 0,
                      acceptCount: Int = 0,
                      maxReadLength: Int = 1048576,
                      keepAliveTimeout: Double = 5.0,
                      handler: @escaping HTTPRequestHandler) throws {

        // Don't let a signal generated by a broken socket kill the server
        signal(SIGPIPE, SIG_IGN)

        if queueCount > 0 {
            queueMax = queueCount
        }
        if acceptCount > 0 {
            acceptMax = acceptCount
        }

        pruneSocketTimer.setEventHandler { [weak self] in
            self?.clientSocketHandlerManager.prune()
        }
        pruneSocketTimer.schedule(deadline: .now() + keepAliveTimeout,
                                  repeating: .seconds(Int(keepAliveTimeout)))
        pruneSocketTimer.resume()

        var readQueues = [DispatchQueue]()
        var writeQueues = [DispatchQueue]()
        let acceptQueue = DispatchQueue(label: "Accept Queue", qos: .default, attributes: .concurrent)

        let acceptSemaphore = DispatchSemaphore.init(value: acceptMax)

        for idx in 0..<queueMax {
            readQueues.append(DispatchQueue(label: "Read Queue \(idx)"))
            writeQueues.append(DispatchQueue(label: "Write Queue \(idx)"))
        }

        print("Started server on port \(self.serverSocket.listeningPort) with \(self.queueMax) serial queues of each type and \(self.acceptMax) accept sockets")

        var listenerCount = 0
        DispatchQueue.global().async {
            repeat {
                do {
                    let acceptedClientSocket: Manager.Handler.Socket? = try self.serverSocket.acceptClientConnection()
                    guard let clientSocket = acceptedClientSocket else {
                        if self.isShuttingDown {
                            print("Received nil client socket - exiting accept loop")
                        }
                        break
                    }
                    let handler = Manager.Handler()
                    listenerCount += 1
                    acceptSemaphore.wait()
                    acceptQueue.async { [weak handler] in
                        handler?.handle(socket: clientSocket)
                        acceptSemaphore.signal()
                    }
                    self.clientSocketHandlerManager.add(handler: handler)
                } catch let error {
                    print("Error accepting client connection: \(error)")
                }
            } while !self.isShuttingDown
        }
    }

    /// Stop the server and close the sockets
    public func stop() {
        isShuttingDown = true
        clientSocketHandlerManager.closeAll()
    }

    /// Count the connections - can be used in XCTests
    public var connectionCount: Int {
        return clientSocketHandlerManager.count
    }
}
