//
//  HDHTTPServer.swift
//  HDHTTPServer
//
//  Created by Yuki Takahashi on 2017/11/11.
//

import Dispatch

public struct StreamingParser { }

public class SocketConnectionListener {
    var isOpen: Bool = false
    func process() { }
    func close() { }
    func closeIfIdleSocket() { }
}

public struct HTTPRequest { }

public struct HTTPResponseWriter { }

public struct HTTPBodyProcessing { }

public typealias HTTPRequestHandler = (HTTPRequest, HTTPResponseWriter) -> HTTPBodyProcessing

public class HDHTTPServer {
    private let serverSocket: SSSocket

    private var connectionListenerList: ConnectionListenerCollection

    /// Timer that cleans up idle sockets on expire
    private let pruneSocketTimer: DispatchSourceTimer = DispatchSource.makeTimerSource(queue: DispatchQueue(label: "pruneSocketTimer"))

    public var port: Int {
        return Int(serverSocket.listeningPort)
    }

    public init(serverSocket: SSSocket, connectionListerList: ConnectionListenerCollection) {
        self.serverSocket = serverSocket
        self.connectionListenerList = connectionListerList
    }

    private var queueMax: Int = 4
    private var acceptMax: Int = 8
    private let _isShuttingDownLock = DispatchSemaphore(value: 1)
    private var _isShuttingDown: Bool = false

    var isShuttingDown: Bool {
        get {
            _isShuttingDownLock.wait()
            defer {
                _isShuttingDownLock.signal()
            }
            return _isShuttingDown
        }
        set {
            _isShuttingDownLock.wait()
            defer {
                _isShuttingDownLock.signal()
            }
            _isShuttingDown = newValue
        }
    }

    /// Starts the server listening on a given port
    ///
    /// - Parameters:
    ///   - port: TCP port. See listen(2)
    ///   - handler: Function that creates the HTTP Response from the HTTP Request
    /// - Throws: Error (usually a socket error) generated
    public func start(port: Int = 0,
                      queueCount: Int = 0,
                      acceptCount: Int = 0,
                      maxReadLength: Int = 1048576,
                      keepAliveTimeout: Double = 5.0,
                      handler: @escaping HTTPRequestHandler) throws {

        // Don't let a signal generated by a broken socket kill the server
        signal(SIGPIPE, SIG_IGN)

        if queueCount > 0 {
            queueMax = queueCount
        }
        if acceptCount > 0 {
            acceptMax = acceptCount
        }

        pruneSocketTimer.setEventHandler { [weak self] in
            self?.connectionListenerList.prune()
        }
        pruneSocketTimer.schedule(deadline: .now() + keepAliveTimeout,
                                  repeating: .seconds(Int(keepAliveTimeout)))
        pruneSocketTimer.resume()

        var readQueues = [DispatchQueue]()
        var writeQueues = [DispatchQueue]()
        let acceptQueue = DispatchQueue(label: "Accept Queue", qos: .default, attributes: .concurrent)

        let acceptSemaphore = DispatchSemaphore.init(value: acceptMax)

        for idx in 0..<queueMax {
            readQueues.append(DispatchQueue(label: "Read Queue \(idx)"))
            writeQueues.append(DispatchQueue(label: "Write Queue \(idx)"))
        }

        print("Started server on port \(self.serverSocket.listeningPort) with \(self.queueMax) serial queues of each type and \(self.acceptMax) accept sockets")

        var listenerCount = 0
        DispatchQueue.global().async {
            repeat {
//                do {
//                    let acceptedClientSocket = try self.serverSocket.acceptClientConnection()
//                    guard let clientSocket = acceptedClientSocket else {
//                        if self.isShuttingDown {
//                            print("Received nil client socket - exiting accept loop")
//                        }
//                        break
//                    }
                    //                    let streamingParser = StreamingParser(handler: handler, connectionCounter: self, keepAliveTimeout: keepAliveTimeout)
//                    let streamingParser = StreamingParser()
//                    let readQueue = readQueues[listenerCount % self.queueMax]
//                    let writeQueue = writeQueues[listenerCount % self.queueMax]
                    //                    let listener = SocketConnectionListener(socket: clientSocket, parser: streamingParser, readQueue: readQueue, writeQueue: writeQueue, maxReadLength: maxReadLength)
                    let listener = SocketConnectionListener()
                    listenerCount += 1
                    acceptSemaphore.wait()
                    acceptQueue.async { [weak listener] in
                        listener?.process()
                        acceptSemaphore.signal()
                    }
                    self.connectionListenerList.add(listener)
//                } catch let error {
//                    print("Error accepting client connection: \(error)")
//                }
            } while !self.isShuttingDown
        }
    }

    /// Stop the server and close the sockets
    public func stop() {
        isShuttingDown = true
        connectionListenerList.closeAll()
    }

    /// Count the connections - can be used in XCTests
    public var connectionCount: Int {
        return connectionListenerList.count
    }
}

public protocol ConnectionListenerCollection {
    func add(_ listener: SocketConnectionListener)
    func closeAll()
    func prune()
    var count: Int { get }
}
